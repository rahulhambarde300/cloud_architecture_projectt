AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template to launch AngularCRUD

Resources:
  
  FlightsTable:
    Type: AWS::DynamoDB::Table
    Properties: 
      TableName: flight
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: N
      KeySchema: 
        - AttributeName: id
          KeyType: HASH # Partition key
      BillingMode: PAY_PER_REQUEST # On-demand pricing
      TimeToLiveSpecification:
        AttributeName: ttl 
        Enabled: false
      Tags:
        - Key: Environment
          Value: Development

  HotelsTable:
    Type: AWS::DynamoDB::Table
    Properties: 
      TableName: hotel
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: N
      KeySchema: 
        - AttributeName: id
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST 
      TimeToLiveSpecification:
        AttributeName: ttl 
        Enabled: false
      Tags:
        - Key: Environment
          Value: Development

  FlightsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: flights
      Handler: index.handler
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Runtime: nodejs20.x
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const {
            DynamoDBDocumentClient,
            GetCommand,
            PutCommand,
            ScanCommand,
            DeleteCommand,
          } = require("@aws-sdk/lib-dynamodb");

          const client = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(client);

          const TABLE_NAME = "flight";

          exports.handler = async (event) => {
            try {
              const httpMethod = event.httpMethod || event.requestContext.http.method;
              const queryStringParameters = event.queryStringParameters;
              const body = event.body;

              console.log(event, httpMethod, body, queryStringParameters);
              const id_query = queryStringParameters?.id;
              const from_query = queryStringParameters?.from;
              const to_query = queryStringParameters?.to;

              if (httpMethod === "GET") {
                if (id_query) {
                  const getCommand = new GetCommand({
                    TableName: TABLE_NAME,
                    Key: { id: Number(id_query) },
                  });

                  const result = await ddbDocClient.send(getCommand);
                  return {
                    statusCode: 200,
                    body: JSON.stringify(result.Item || { message: "Flight not found" }),
                  };
                }

                const scanCommand = new ScanCommand({ TableName: TABLE_NAME });
                const result = await ddbDocClient.send(scanCommand);
                const filteredItems = result.Items.filter((item) => {
                  let matches = true;
                  if (from_query) matches = matches && item.from === from_query;
                  if (to_query) matches = matches && item.to === to_query;
                  return matches;
                });
                return {
                  statusCode: 200,
                  body: JSON.stringify(filteredItems || []),
                };
              } else if (httpMethod === "POST") {
                const { id, from, to, date } = JSON.parse(body);

                if (!id || !from || !to || !date) {
                  return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing required fields" }),
                  };
                }

                const putCommand = new PutCommand({
                  TableName: TABLE_NAME,
                  Item: { id: Number(id), from, to, date },
                });

                await ddbDocClient.send(putCommand);
                return {
                  statusCode: 201,
                  body: JSON.stringify({ message: "Flight added successfully" }),
                };
              } else if (httpMethod === "DELETE") {
                const { id } = queryStringParameters;

                if (!id) {
                  return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing flight ID" }),
                  };
                }

                const deleteCommand = new DeleteCommand({
                  TableName: TABLE_NAME,
                  Key: { id: Number(id) },
                });

                await ddbDocClient.send(deleteCommand);
                return {
                  statusCode: 200,
                  body: JSON.stringify({ message: "Flight deleted successfully" }),
                };
              } else {
                return {
                  statusCode: 405,
                  body: JSON.stringify({ message: "Method Not Allowed" }),
                };
              }
            } catch (error) {
              console.error("Error:", error);
              return {
                statusCode: 500,
                body: JSON.stringify({
                  message: "Internal Server Error",
                  error: error.message,
                }),
              };
            }
          };




  HotelsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: hotels
      Handler: index.handler
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Runtime: nodejs20.x
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const {
            DynamoDBDocumentClient,
            GetCommand,
            PutCommand,
            ScanCommand,
            DeleteCommand,
          } = require("@aws-sdk/lib-dynamodb");

          // Initialize DynamoDB clients
          const client = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(client);

          // Constants
          const TABLE_NAME = "hotel";

          // Lambda handler
          exports.handler = async (event) => {
            try {
              const httpMethod = event.httpMethod || event.requestContext.http.method;
              const queryStringParameters = event.queryStringParameters;
              const body = event.body;

              console.log("Event:", event);
              console.log("HTTP Method:", httpMethod);
              console.log("Body:", body);
              console.log("Query Parameters:", queryStringParameters);
              const id_query = queryStringParameters?.id;
              const city_query = queryStringParameters?.city;

              switch (httpMethod) {
                case "GET":
                  if (id_query) {
                    // Retrieve a specific hotel by ID
                    const getCommand = new GetCommand({
                      TableName: TABLE_NAME,
                      Key: { id: Number(id_query) },
                    });
                    const result = await ddbDocClient.send(getCommand);

                    return {
                      statusCode: 200,
                      body: JSON.stringify(result.Item || { message: "Hotel not found" }),
                    };
                  }

                  // Retrieve all hotels
                  const scanCommand = new ScanCommand({ TableName: TABLE_NAME });
                  const result = await ddbDocClient.send(scanCommand);
                  const filteredItems = result.Items.filter((item) => {
                    let matches = true;
                    if (city_query) matches = matches && item.city === city_query;
                    return matches;
                  });
                  return {
                    statusCode: 200,
                    body: JSON.stringify(filteredItems || []),
                  };

                case "POST":
                  // Add a new hotel
                  const { id, name, city, stars } = JSON.parse(body);

                  if (!name || !city || !stars) {
                    return {
                      statusCode: 400,
                      body: JSON.stringify({ message: "Missing required fields" }),
                    };
                  }
                  let newID = id ? id : Math.floor(Math.random() * 1000000);
                  const putCommand = new PutCommand({
                    TableName: TABLE_NAME,
                    Item: { id: Number(newID), name, city, stars },
                  });
                  await ddbDocClient.send(putCommand);

                  return {
                    statusCode: 201,
                    body: JSON.stringify({ message: "Hotel added successfully" }),
                  };

                case "DELETE":
                  // Delete a hotel by ID
                  const { id: deleteId } = queryStringParameters;

                  if (!deleteId) {
                    return {
                      statusCode: 400,
                      body: JSON.stringify({ message: "Missing hotel ID" }),
                    };
                  }

                  const deleteCommand = new DeleteCommand({
                    TableName: TABLE_NAME,
                    Key: { id: Number(deleteId) },
                  });
                  await ddbDocClient.send(deleteCommand);

                  return {
                    statusCode: 200,
                    body: JSON.stringify({ message: "Hotel deleted successfully" }),
                  };

                default:
                  // Unsupported HTTP method
                  return {
                    statusCode: 405,
                    body: JSON.stringify({ message: "Method Not Allowed" }),
                  };
              }
            } catch (error) {
              console.error("Error:", error);

              return {
                statusCode: 500,
                body: JSON.stringify({
                  message: "Internal Server Error",
                  error: error.message,
                }),
              };
            }
          };

  EmailFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: hotels
      Handler: index.handler
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/LabRole'
      Runtime: nodejs20.x
      Code:
        ZipFile: |
          const { SNSClient, PublishCommand } = require('@aws-sdk/client-sns');

          const snsClient = new SNSClient({ region: 'us-east-1' });
          const TOPIC_ARN = 'arn:aws:sns:us-east-1:562896989310:NewFlight'; // Replace with your SNS Topic ARN

          exports.handler = async (event) => {
            try {
              // Extract the message from the SNS event
              const message = JSON.parse(event.Records[0].Sns.Message);
              
              // Destructure the values from the message
              const { from, to, date } = message;

              const notificationMessage = `New Flight Added:
                From: ${from}
                To: ${to}
                Date: ${date}`;

              const params = {
                Message: notificationMessage,
                Subject: `New Flight Notification`,
                TopicArn: !Ref NewFlightSNSTopic,
              };

              const command = new PublishCommand(params);
              await snsClient.send(command);

              return {
                statusCode: 200,
                body: JSON.stringify({ message: 'Notification sent successfully.' }),
              };
            } catch (error) {
              console.error(error);
              return {
                statusCode: 500,
                body: JSON.stringify({ message: 'Failed to send notification.', error: error.message }),
              };
            }
          };

  NewFlightSNSTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      TopicName: 'NewFlight'  # Name of the SNS Topic
      DisplayName: 'New Flight Notifications'  # Display name for the topic

          
  FlightsFunctionUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt FlightsFunction.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: ["*"] 
        AllowMethods: ["GET", "POST", "DELETE"]
        AllowHeaders: ["*"]  
        MaxAge: 3600
  
  FlightsFunctionUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref FlightsFunction
      Action: lambda:InvokeFunctionUrl
      Principal: "*"
      FunctionUrlAuthType: NONE

  HotelsFunctionUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt HotelsFunction.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: ["*"]
        AllowMethods: ["GET", "POST", "DELETE"]
        AllowHeaders: ["*"]  
        MaxAge: 3600

  HotelsFunctionUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref HotelsFunction
      Action: lambda:InvokeFunctionUrl
      Principal: "*"
      FunctionUrlAuthType: NONE
  
  EmailsFunctionUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt EmailFunction.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: ["*"] 
        AllowMethods: ["GET", "POST", "DELETE"]
        AllowHeaders: ["*"]  
        MaxAge: 3600
  
  FlightsFunctionUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref EmailFunction
      Action: lambda:InvokeFunctionUrl
      Principal: "*"
      FunctionUrlAuthType: NONE

Outputs:
  FlightsFunctionURLADD:
    Description: Flights function url
    Value: !GetAtt FlightsFunctionUrl.FunctionUrl

  HotelsFunctionURLADD:
    Description: Hotels function url
    Value: !GetAtt HotelsFunctionUrl.FunctionUrl
  